Problem-1: https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/

class Solution {
   // Function to convert an infix expression to a postfix expression.
  
   public static String infixToPostfix(String s) {
       // Your code here
       
        Stack<Character> st=new Stack<>();
        String ans = new String();
       
        for(int i = 0; i < s.length();i++){
           if(Character.isLetterOrDigit(s.charAt(i))){
               ans += s.charAt(i);
            } else if(s.charAt(i) == '('){
                st.push(s.charAt(i));
            } else if(s.charAt(i) == ')'){
                while(!st.empty() && st.peek() != '('){
                   ans+=st.pop();
                }
                if(!st.empty()){
                   st.pop();
                }
            } else {
                while(!st.empty() && prec(st.peek()) >= prec(s.charAt(i)) ){
                   ans += st.pop();
                }
                st.push(s.charAt(i));
            }
        }
       
        while(!st.empty()){
           ans += st.pop();
        }
        
        return ans;
   }
}

Problem-2: https://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/

class GfG{
    int min = Integer.MAX_VALUE;
    
	public void push(int a, Stack<Integer> s) {
	    //add code here.
	    if(s.size() == 0){
	        s.push(a);
	        min = a;
	    } else {
	        if(a < min){
	            int val = 2 * a - min;
	            s.push(val);
	            min = a;
	        } else {
	            s.push(a);
	        }
	    }
	}
	
	public int pop(Stack<Integer> s) {
        //add code here.
        int val = s.pop();
        if(val < min){
            int v = min;
            min = min * 2 - v;
            return min;
        } else {
            return min;
        }
	}
	
	public int min(Stack<Integer> s) {
           //add code here.
           return min;
	}
	
	public boolean isFull(Stack<Integer> s, int n) {
           //add code here.
           return s.size() == n;
	}
	
	public boolean isEmpty(Stack<Integer> s) {
           //add code here.
           return s.size() == 0;
	}
}

Problem-3: https://www.geeksforgeeks.org/length-of-the-longest-valid-substring/

class Solution {
    static int findMaxLen(String S) {
        // code here
        int max = 0;
        Stack<Integer> st = new Stack<>();
        st.push(-1);
        
        for(int i = 0; i < S.length(); i++){
            if(S.charAt(i) =='('){
                st.push(i);
            }
            else{
                st.pop();
                if(st.empty()){
                    st.push(i);
                } else {
                    max = Math.max(max,i-st.peek());
                }
            }
        }
        return max;
    }
}

Problem-4: https://www.geeksforgeeks.org/find-expression-duplicate-parenthesis-not/

import java.util.Scanner;
import java.util.Stack;

public class RedundantParenthesisCheck {
    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        String expr = scn.nextLine();

        System.out.println(isRedundantParenthesis(expr));
    }

    private static boolean isRedundantParenthesis(String str){
        boolean ans = false;
        Stack<Character> st = new Stack<>();

        for(int i = 0; i < str.length(); i++){
            char ch = str.charAt(i);

            if(isOperator(ch) || ch == '(')
                st.push(ch);
            else {
                if(st.size() > 0 && st.peek() == '(')
                    ans = true;
                while (st.size() > 0 && isOperator(st.peek())){
                    st.pop();
                }
                if(st.size() > 0)
                    st.pop();
            }
        }
        return ans;
    }

    private static boolean isOperator(char op){
        return op == '+' || op == '-' || op == '*' || op == '/';
    }
}

Problem-5: https://www.geeksforgeeks.org/stack-permutations-check-if-an-array-is-stack-permutation-of-other/

class Solution {
    public static int isStackPermutation(int N, int[] pushed, int[] popped) {
        // code here
        Stack<Integer> st = new Stack<>();
        int j = 0;
        
        for(int ele: pushed){
            st.push(ele);
            while(st.size() > 0 && st.peek() == popped[j]){
                st.pop();
                j++;
            }
        }
        
        return j == popped.length ? 1 : 0;
    }
}

Problem-6: https://www.geeksforgeeks.org/count-natural-numbers-whose-permutation-greater-number/

// Java program to count the number less than N,
// whose all permutation is greater
// than or equal to the number.
import java.util.Stack;
 
 
class GFG
{
    // Return the count of the number having all
    // permutation greater than or equal to the number.
 
    static int countNumber(int n)
    {
        int result = 0;
 
        // Pushing 1 to 9 because all number from 1
        // to 9 have this property.
        Stack<Integer> s = new Stack<>();
        for (int i = 1; i <= 9; i++)
        {
 
            if (i <= n)
            {
                s.push(i);
                result++;
            }
 
            // take a number from stack and add
            // a digit smaller than or equal to last digit
            // of it.
            while (!s.empty())
            {
                int tp = s.pop();
                
                for (int j = tp % 10; j <= 9; j++)
                {
                    int x = tp * 10 + j;
                    if (x <= n) {
                        s.push(x);
                        result++;
                    }
                }
            }
        }
 
        return result;
    }
 
    // Driven Code
    public static void main(String[] args)
    {
        int n = 15;
        System.out.println(countNumber(n));
    }
}
 

Problem-7: https://www.geeksforgeeks.org/sort-a-stack-using-recursion/

package RecursionPractice;
import java.util.Stack;

public class SortStack {
    public static void main(String[] args) {
        Stack<Integer> st = new Stack<>();
        st.push(2);
        st.push(0);
        st.push(1);
        st.push(5);
        st.push(4);
        System.out.println(st);
        sortStack(st);
        System.out.println(st);
    }

    private static void sortStack(Stack<Integer> st){
        if(st.size() == 1){
            return;
        }

        int temp = st.pop();
        sortStack(st);
        insert(st, temp);
    }

    private static void insert(Stack<Integer> st, int temp){
        if(st.size() == 0 || st.peek() <= temp){
            st.push(temp);
            return;
        }

        int val = st.pop();
        insert(st, temp);
        st.push(val);
    }
}
